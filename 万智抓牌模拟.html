<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ä¸‡æ™ºç‰ŒÂ·å®Œå…¨ä½“æ¨¡æ‹Ÿå™¨ (ä¸»ç‰Œ/å¤‡ç‰Œï½œæ¢å¤‡åŠŸèƒ½)</title>
    <style>
        /* ========== æ ·å¼å®Œå…¨ä¿ç•™ï¼Œè¿½åŠ æ¢å¤‡é¢æ¿æ ·å¼ ========== */
        * {
            box-sizing: border-box;
            font-family: system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif;
        }
        body {
            background: #2a2a2a;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 0;
            padding: 16px;
        }
        .simulator {
            max-width: 1300px;
            width: 100%;
            background: #1e1e2f;
            border-radius: 32px;
            padding: 24px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.6);
            color: #f0e6d0;
            border: 1px solid #4a3f2e;
        }
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 16px;
            margin-bottom: 24px;
        }
        .stats {
            background: #2c2c3a;
            padding: 12px 20px;
            border-radius: 60px;
            font-size: 1.2rem;
            font-weight: 500;
            border: 1px solid #6b5a44;
            box-shadow: inset 0 2px 5px #0a0a0a;
            display: flex;
            gap: 24px;
            flex-wrap: wrap;
        }
        .stats-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .stats-item span {
            color: #ffd966;
            font-weight: 700;
            min-width: 2.5rem;
            text-align: right;
        }
        .button-group {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            align-items: center;
        }
        button {
            background: #4b3a2b;
            border: none;
            color: #ffebc6;
            font-size: 1rem;
            font-weight: 600;
            padding: 10px 20px;
            border-radius: 40px;
            cursor: pointer;
            transition: 0.2s;
            border: 1px solid #7f6b4f;
            box-shadow: 0 4px 0 #2a1f15;
            letter-spacing: 0.5px;
            white-space: nowrap;
        }
        button:hover:not(:disabled) {
            background: #5f4a36;
            transform: translateY(-2px);
            box-shadow: 0 6px 0 #2a1f15;
        }
        button:active:not(:disabled) {
            transform: translateY(2px);
            box-shadow: 0 1px 0 #2a1f15;
        }
        button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            box-shadow: none;
        }
        .last-draw {
            background: #2e2b22;
            padding: 16px 20px;
            border-radius: 20px;
            margin: 24px 0;
            border-left: 8px solid #b89b6e;
            font-size: 1.4rem;
            display: flex;
            align-items: center;
            gap: 16px;
            flex-wrap: wrap;
        }
        .last-draw .label {
            color: #b89b6e;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-size: 0.9rem;
        }
        .last-draw .card-name {
            background: #0e0d12;
            padding: 8px 24px;
            border-radius: 60px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            color: #ffe2a4;
            font-size: 1.6rem;
            word-break: break-word;
        }
        .search-area {
            background: #2e2b22;
            border-radius: 30px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid #5b4f3b;
        }
        .search-header {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            align-items: center;
            margin-bottom: 16px;
        }
        .search-input {
            flex: 1 1 250px;
            background: #1a1a24;
            border: 1px solid #7f6b4f;
            border-radius: 60px;
            padding: 12px 20px;
            color: #ffebc6;
            font-size: 1rem;
            outline: none;
        }
        .search-input::placeholder {
            color: #6b6253;
        }
        .search-results {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
            min-height: 50px;
            background: #25232b;
            border-radius: 30px;
            padding: 16px;
        }
        .search-card {
            background: #352d22;
            border: 2px solid #c1a066;
            padding: 6px 16px;
            border-radius: 40px;
            font-size: 1rem;
            color: #ffdead;
            cursor: pointer;
            transition: 0.1s;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .search-card:hover {
            background: #4f422f;
            transform: scale(1.02);
        }
        .search-card.selected {
            background: #5b4a30;
            border-color: #ffd966;
            box-shadow: 0 0 0 2px #ffb347;
        }
        .search-actions {
            display: flex;
            gap: 8px;
            margin-top: 12px;
            flex-wrap: wrap;
            align-items: center;
        }
        .action-tip {
            color: #b89b6e;
            margin-right: 10px;
        }
        .zone-row {
            display: flex;
            flex-wrap: wrap;
            gap: 16px;
            justify-content: space-between;
        }
        .zone {
            flex: 1 1 200px;
            background: #25232b;
            border-radius: 24px;
            padding: 16px;
            border: 1px solid #5b4f3b;
            min-width: 180px;
        }
        .zone-title {
            font-size: 1.2rem;
            margin-bottom: 12px;
            display: flex;
            justify-content: space-between;
            border-bottom: 2px solid #4a3f2e;
            padding-bottom: 4px;
        }
        .zone-title span {
            background: #3d3529;
            padding: 2px 12px;
            border-radius: 20px;
            font-size: 0.9rem;
        }
        .zone-cards {
            min-height: 100px;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-content: flex-start;
        }
        .card {
            background: #352d22;
            border: 2px solid #c1a066;
            padding: 6px 12px;
            border-radius: 30px;
            font-size: 0.9rem;
            box-shadow: 0 2px 5px #0f0e0a;
            color: #ffdead;
            font-weight: 500;
            cursor: pointer;
            transition: 0.1s;
            white-space: nowrap;
            user-select: none;
        }
        .card:hover {
            background: #4f422f;
            transform: scale(1.02);
        }
        .card.selected {
            background: #5b4a30;
            border-color: #ffd966;
            box-shadow: 0 0 0 2px #ffb347;
        }
        .card::before {
            content: "ğŸƒ";
            margin-right: 4px;
            opacity: 0.7;
            font-size: 0.8rem;
        }
        .empty-message {
            color: #7a6e5a;
            font-style: italic;
            width: 100%;
            text-align: center;
            padding: 20px 0;
        }
        .action-bar {
            margin: 20px 0 10px;
            padding: 12px 20px;
            background: #2e2b22;
            border-radius: 60px;
            display: flex;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
        }
        .selected-info {
            color: #b89b6e;
            font-weight: 400;
        }
        .action-buttons {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }
        .action-btn {
            background: #3a5a4a;
            border-color: #6b9b7a;
            box-shadow: 0 4px 0 #1d3a2a;
        }
        .action-btn:hover {
            background: #4e7762;
        }
        .deck-manager {
            background: #2e2b22;
            border-radius: 30px;
            padding: 20px;
            margin-top: 20px;
        }
        .deck-textarea {
            width: 100%;
            background: #1a1a24;
            border: 1px solid #7f6b4f;
            border-radius: 20px;
            padding: 16px;
            color: #ffebc6;
            font-size: 1rem;
            font-family: monospace;
            min-height: 150px;
            resize: vertical;
            margin-bottom: 16px;
        }
        .deck-textarea::placeholder {
            color: #6b6253;
        }
        /* æ¢å¤‡é¢æ¿ */
        .sideboard-panel {
            background: #2e2b22;
            border-radius: 30px;
            padding: 20px;
            margin-top: 20px;
            border: 2px solid #b89b6e;
        }
        .sideboard-row {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }
        .sideboard-col {
            flex: 1;
            background: #25232b;
            border-radius: 24px;
            padding: 16px;
            border: 1px solid #5b4f3b;
        }
        .sideboard-actions {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }
        /* å¡å›¾æ‚¬æµ® */
        #card-tooltip {
            position: fixed;
            display: none;
            border: 3px solid #d4af37;
            background: #1e1a14;
            padding: 6px;
            border-radius: 16px;
            box-shadow: 0 8px 20px black;
            z-index: 20000;
            pointer-events: none;
            max-width: 240px;
            max-height: 340px;
        }
        #card-tooltip img {
            display: block;
            width: 100%;
            height: auto;
            border-radius: 10px;
            border: 1px solid #7f6b4f;
            background: #2f2a22;
        }
        [data-cardname] {
            cursor: help;
        }
        /* å¯¹è¯æ¡† */
        .deck-dialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #2c2c3a;
            border: 2px solid #b89b6e;
            border-radius: 30px;
            padding: 24px;
            z-index: 1000;
            box-shadow: 0 10px 30px black;
            min-width: 300px;
            display: none;
        }
        .overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.7);
            z-index: 999;
            display: none;
        }
        footer {
            text-align: center;
            margin-top: 20px;
            color: #6b6253;
            font-size: 0.85rem;
        }
    </style>
</head>
<body>
    <div class="simulator">
        <!-- çŠ¶æ€æ  (ä¸å˜) -->
        <div class="header">
            <div class="stats">
                <div class="stats-item">ğŸ“¦ ç‰Œåº“ <span id="deckCount">53</span></div>
                <div class="stats-item">ğŸ–ï¸ æ‰‹ç‰Œ <span id="handCount">7</span></div>
                <div class="stats-item">âš¡ è°ƒåº¦ <span id="mulliganCount">0</span></div>
            </div>
            <div class="button-group">
                <button id="resetBtn">ğŸ”„ é‡æ–°æ´—ç‰Œ</button>
            </div>
        </div>

        <!-- æœ€åä¸€æ¬¡æŠ“ç‰Œæ˜¾ç¤º -->
        <div class="last-draw">
            <span class="label">æœ€åä¸€æ¬¡æŠ“ç‰Œ</span>
            <span class="card-name" id="lastDrawCard" data-cardname="">â€”â€”</span>
        </div>

        <!-- æœç´¢åŒºåŸŸ (ä¸å˜) -->
        <div class="search-area">
            <div class="search-header">
                <input type="text" id="searchInput" class="search-input" placeholder="è¾“å…¥å¡åæœç´¢ç‰Œåº“ (ä¸åŒºåˆ†å¤§å°å†™, æ¨¡ç³Š)">
                <button id="searchBtn">ğŸ” æœç´¢</button>
            </div>
            <div class="search-results" id="searchResults"></div>
            <div class="search-actions" id="searchActions" style="display: none;">
                <span class="action-tip">å¯¹ <span id="selectedSearchCard">å¡å</span> çš„æ“ä½œï¼š</span>
                <button class="action-btn" data-target="battlefield">âš”ï¸ æ”¾å…¥æˆ˜åœº</button>
                <button class="action-btn" data-target="graveyard">ğŸ’€ æ”¾å…¥å¢“åœ°</button>
                <button class="action-btn" data-target="exile">ğŸŒ‘ æ”¾å…¥æ”¾é€åŒº</button>
                <button class="action-btn" data-target="hand">ğŸ–ï¸ åŠ å…¥æ‰‹ç‰Œ</button>
                <button class="action-btn" data-target="decktop">ğŸ“Œ æ”¾ç½®åˆ°ç‰Œåº“é¡¶</button>
                <button id="cancelSearchAction">âŒ å–æ¶ˆ</button>
            </div>
        </div>

        <!-- åŠ¨æ€æŒ‰é’®åŒºåŸŸ (ä¸å˜) -->
        <div id="initialButtons" class="button-group" style="margin-bottom: 16px;">
            <button id="acceptInitialBtn">âœ… æ¥å—æ‰‹ç‰Œ (å¼€å§‹æ¸¸æˆ)</button>
            <button id="mulliganBtn">ğŸ”„ è°ƒåº¦</button>
        </div>
        <div id="mulliganButtons" class="button-group" style="display: none; margin-bottom: 16px;">
            <button id="acceptXBtn">ğŸ“¥ æ¥å—æ‰‹ç‰Œ (æ”¾å› <span id="xCount">0</span> å¼ )</button>
            <button id="remulliganBtn">ğŸ”„ é‡æ–°è°ƒåº¦</button>
        </div>
        <div id="selectButtons" class="button-group" style="display: none; margin-bottom: 16px;">
            <div class="selection-info">
                <span>ğŸ“Œ å·²é€‰ <span id="selectedCount">0</span>/<span id="targetX">0</span></span>
                <button id="confirmReturnBtn" disabled>âœ… ç¡®è®¤æ”¾å›</button>
                <button id="cancelSelectBtn">âŒ å–æ¶ˆ</button>
            </div>
        </div>
        <div id="playButtons" class="button-group" style="display: none; margin-bottom: 16px;">
            <button id="drawBtn">âš¡ æŠ“ç‰Œ</button>
        </div>

        <!-- æ“ä½œæ  (æ˜¾ç¤ºå½“å‰é€‰ä¸­ç‰ŒåŠç§»åŠ¨é€‰é¡¹) -->
        <div class="action-bar" id="actionBar" style="display: none;">
            <div class="selected-info" id="selectedInfo">æœªé€‰ä¸­ä»»ä½•ç‰Œ</div>
            <div class="action-buttons" id="actionButtons"></div>
        </div>

        <!-- ä¸»è¦åŒºåŸŸï¼šæ‰‹ç‰Œã€æˆ˜åœºã€å¢“åœ°ã€æ”¾é€åŒº -->
        <div class="zones-container">
            <div class="zone">
                <div class="zone-title">ğŸƒ æ‰‹ç‰Œ <span id="handCount2">0</span></div>
                <div class="zone-cards" id="handZone"></div>
            </div>
            <div class="zone-row">
                <div class="zone">
                    <div class="zone-title">âš”ï¸ æˆ˜åœº <span id="battlefieldCount">0</span></div>
                    <div class="zone-cards" id="battlefieldZone"></div>
                </div>
                <div class="zone">
                    <div class="zone-title">ğŸ’€ å¢“åœ° <span id="graveyardCount">0</span></div>
                    <div class="zone-cards" id="graveyardZone"></div>
                </div>
                <div class="zone">
                    <div class="zone-title">ğŸŒ‘ æ”¾é€åŒº <span id="exileCount">0</span></div>
                    <div class="zone-cards" id="exileZone"></div>
                </div>
            </div>
        </div>

        <!-- å¡ç»„ç®¡ç†åŒºåŸŸï¼ˆå¢åŠ æ¢å¤‡æŒ‰é’®ï¼‰ -->
        <div class="deck-manager">
            <textarea id="deckInput" class="deck-textarea" placeholder="è¾“å…¥è‡ªå®šä¹‰å¡ç»„ï¼Œæ¯è¡Œæ ¼å¼ï¼šæ•°é‡ å¡åã€‚ç©ºè¡Œå‰ä¸ºä¸»ç‰Œï¼Œç©ºè¡Œåä¸ºå¤‡ç‰Œã€‚&#10;ä¾‹å¦‚ï¼š&#10;4 Banishing Knack&#10;4 Dizzy Spell&#10;&#10;2 Island&#10;1 Mountain">4 Banishing Knack
4 Dizzy Spell
10 Island
4 LÃ³rien Revealed
4 Molten Tributary
4 Muddle the Mixture
4 Reckless Fireweaver
4 Retraction Helix
4 Secret Door
4 Sewer-veillance Cam
4 Silver Myr
2 Silverbluff Bridge
4 Vedalken Engineer
4 Welder Automaton</textarea>
            <div class="button-group">
                <button id="loadDeckBtn">ğŸ“¥ åŠ è½½æ­¤å¡ç»„</button>
                <button id="saveDeckBtn">ğŸ’¾ ä¿å­˜å½“å‰å¡ç»„</button>
                <button id="defaultDeckBtn">ğŸ”„ æ¢å¤é»˜è®¤å¡ç»„</button>
                <button id="loadSavedBtn">ğŸ“‚ åŠ è½½å·²ä¿å­˜çš„å¡ç»„</button>
                <button id="sideboardBtn">ğŸ”„ æ¢å¤‡</button>  <!-- æ–°å¢æ¢å¤‡æŒ‰é’® -->
            </div>
        </div>

        <!-- æ¢å¤‡é¢æ¿ (åˆå§‹éšè—) -->
        <div id="sideboardPanel" class="sideboard-panel" style="display: none;">
            <div class="sideboard-row">
                <div class="sideboard-col">
                    <div class="zone-title">ä¸»ç‰Œ <span id="panelMainCount">0</span></div>
                    <div class="zone-cards" id="panelMainCards"></div>
                </div>
                <div class="sideboard-col">
                    <div class="zone-title">å¤‡ç‰Œ <span id="panelSideCount">0</span></div>
                    <div class="zone-cards" id="panelSideCards"></div>
                </div>
            </div>
            <div class="sideboard-actions">
                <button id="confirmSideboardBtn" class="action-btn">âœ… ç¡®è®¤æ¢å¤‡</button>
                <button id="cancelSideboardBtn">âŒ å–æ¶ˆ</button>
            </div>
        </div>

        <footer>ç‚¹å‡»ä»»ä½•ç‰Œå¯ç§»åŠ¨ Â· æœç´¢ç‰Œåº“åç‚¹å‡»ç»“æœå¯æ“ä½œ Â· é¼ æ ‡æ‚¬æµ®æ˜¾ç¤ºå¡å›¾ Â· ç©ºè¡Œåˆ†éš”ä¸»/å¤‡</footer>
    </div>

    <!-- å¡ç»„é€‰æ‹©å¯¹è¯æ¡† -->
    <div class="overlay" id="overlay"></div>
    <div class="deck-dialog" id="deckDialog">
        <h3>é€‰æ‹©è¦åŠ è½½çš„å¡ç»„</h3>
        <select id="savedDeckSelect" size="5"></select>
        <div class="button-group">
            <button id="loadSelectedDeck">åŠ è½½</button>
            <button id="closeDeckDialog">å–æ¶ˆ</button>
        </div>
    </div>

    <!-- æ‚¬æµ®å¡å›¾å®¹å™¨ -->
    <div id="card-tooltip"><img src="" alt="å¡å›¾"></div>

    <script>
        (function() {
            // ---------- é»˜è®¤å¡ç»„æ•°æ® (ç”¨äºç”Ÿæˆé»˜è®¤æ–‡æœ¬) ----------
            const DEFAULT_CARD_COUNTS = [
                [4, "Banishing Knack"],
                [4, "Dizzy Spell"],
                [10, "Island"],
                [4, "LÃ³rien Revealed"],
                [4, "Molten Tributary"],
                [4, "Muddle the Mixture"],
                [4, "Reckless Fireweaver"],
                [4, "Retraction Helix"],
                [4, "Secret Door"],
                [4, "Sewer-veillance Cam"],
                [4, "Silver Myr"],
                [2, "Silverbluff Bridge"],
                [4, "Vedalken Engineer"],
                [4, "Welder Automaton"]
            ];

            // ---------- å…¨å±€çŠ¶æ€ ----------
            let deck = [];
            let hand = [];
            let battlefield = [];
            let graveyard = [];
            let exile = [];

            // ä¸»ç‰Œåˆ—è¡¨ (å±•å¼€çš„å¡åæ•°ç»„) å’Œ å¤‡ç‰Œåˆ—è¡¨
            let mainboardList = [];
            let sideboardList = [];

            let mulliganCount = 0;
            let gamePhase = 'initial';     // 'initial', 'mulligan', 'selecting', 'playing'
            let selectedIndices = [];
            let targetX = 0;
            let selectedCard = null;

            // æœç´¢ç›¸å…³
            let selectedSearchCardName = '';

            // ========== å¡å›¾ç¼“å­˜ ==========
            const cardImageUrlMap = new Map();
            const pendingRequests = new Map();
            const PLACEHOLDER_IMG = 'data:image/svg+xml,%3Csvg xmlns=\'http://www.w3.org/2000/svg\' width=\'200\' height=\'300\' viewBox=\'0 0 200 300\'%3E%3Crect width=\'200\' height=\'300\' fill=\'%23333333\'/%3E%3Ctext x=\'30\' y=\'160\' fill=\'%23aaaaaa\' font-size=\'18\' font-family=\'monospace\'%3Eæš‚æ— å›¾ç‰‡%3C/text%3E%3C/svg%3E';

            async function fetchCardImageUrl(cardName) {
                if (pendingRequests.has(cardName)) return pendingRequests.get(cardName);
                const promise = (async () => {
                    const headers = { 'User-Agent': 'MagicSimulator/1.0', 'Accept': 'application/json' };
                    const url = `https://api.scryfall.com/cards/named?fuzzy=${encodeURIComponent(cardName)}`;
                    try {
                        const response = await fetch(url, { headers });
                        if (!response.ok) throw new Error(`HTTP ${response.status}`);
                        const data = await response.json();
                        let imageUrl = null;
                        if (data.image_uris && data.image_uris.png) {
                            imageUrl = data.image_uris.png;
                        } else if (data.card_faces && data.card_faces[0]?.image_uris?.png) {
                            imageUrl = data.card_faces[0].image_uris.png;
                        }
                        if (imageUrl) {
                            new Image().src = imageUrl;
                            cardImageUrlMap.set(cardName, imageUrl);
                        } else {
                            cardImageUrlMap.set(cardName, null);
                        }
                        return imageUrl;
                    } catch (e) {
                        console.warn(`å¡å›¾è·å–å¤±è´¥ [${cardName}]:`, e);
                        cardImageUrlMap.set(cardName, null);
                        return null;
                    } finally {
                        pendingRequests.delete(cardName);
                    }
                })();
                pendingRequests.set(cardName, promise);
                return promise;
            }

            async function preloadCardImages(cardNames) {
                const unique = [...new Set(cardNames)];
                const needFetch = unique.filter(name => !cardImageUrlMap.has(name));
                for (const name of needFetch) {
                    fetchCardImageUrl(name);
                    await new Promise(r => setTimeout(r, 150));
                }
            }

            // ---------- è¾…åŠ©å‡½æ•°ï¼šè§£æè¡Œæ•°ç»„ä¸ºå±•å¼€å¡å ----------
            function parseLinesToCards(lines) {
                const cards = [];
                for (let line of lines) {
                    line = line.trim();
                    if (line === '') continue;
                    const parts = line.split(' ');
                    const count = parseInt(parts[0], 10);
                    if (isNaN(count) || count <= 0) continue;
                    const name = parts.slice(1).join(' ').trim();
                    if (name === '') continue;
                    for (let i = 0; i < count; i++) cards.push(name);
                }
                return cards;
            }

            // æ–°è§£æå‡½æ•°ï¼šæ ¹æ®ç¬¬ä¸€ä¸ªç©ºè¡Œåˆ†å‰²ä¸»ç‰Œ/å¤‡ç‰Œ
            function parseDeckFull(text) {
                const lines = text.split('\n');
                let mainLines = [], sideLines = [];
                let foundEmpty = false;
                for (let line of lines) {
                    let trimmed = line.trim();
                    if (!foundEmpty && trimmed === '') {
                        foundEmpty = true;
                        continue;
                    }
                    if (!foundEmpty) {
                        mainLines.push(line);
                    } else {
                        if (trimmed !== '') sideLines.push(line);
                    }
                }
                const mainboard = parseLinesToCards(mainLines);
                const sideboard = parseLinesToCards(sideLines);
                return { mainboard, sideboard };
            }

            // æ´—ç‰Œ
            function shuffleArray(arr) {
                for (let i = arr.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [arr[i], arr[j]] = [arr[j], arr[i]];
                }
                return arr;
            }

            // é‡ç½®æ¸¸æˆ (åŸºäºå½“å‰çš„mainboardList)
            function resetGameWithDeck(customMainboard = null) {
                if (customMainboard !== null) {
                    mainboardList = [...customMainboard];
                }
                // ä»ä¸»ç‰Œæ„å»ºç‰Œåº“å¹¶æ´—ç‰Œ
                let fullDeck = shuffleArray([...mainboardList]);
                hand = fullDeck.slice(0, 7);
                deck = fullDeck.slice(7);
                battlefield = [];
                graveyard = [];
                exile = [];
                mulliganCount = 0;
                gamePhase = 'initial';
                selectedIndices = [];
                selectedCard = null;
                selectedSearchCardName = '';
                document.getElementById('searchActions').style.display = 'none';
                
                // é¢„åŠ è½½ä¸»ç‰Œ+å¤‡ç‰Œå¡å›¾
                const allCards = [...mainboardList, ...sideboardList];
                preloadCardImages([...new Set(allCards)]);
                
                updateUI();
            }

            // æ›´æ–°UI (åŸæœ‰é€»è¾‘åŸºæœ¬ä¸å˜ï¼Œåªå¢åŠ å¤‡ç‰Œç›¸å…³ä¸å½±å“)
            function updateUI(lastDrawn = null) {
                document.getElementById('deckCount').textContent = deck.length;
                document.getElementById('handCount').textContent = hand.length;
                document.getElementById('mulliganCount').textContent = mulliganCount;

                if (lastDrawn) {
                    const lastSpan = document.getElementById('lastDrawCard');
                    lastSpan.textContent = lastDrawn;
                    lastSpan.dataset.cardname = lastDrawn;
                } else if (gamePhase === 'initial' || gamePhase === 'mulligan' || gamePhase === 'selecting') {
                    const lastSpan = document.getElementById('lastDrawCard');
                    lastSpan.textContent = 'â€”â€”';
                    delete lastSpan.dataset.cardname;
                }

                // æ˜¾ç¤º/éšè—æŒ‰é’®ç»„
                document.getElementById('initialButtons').style.display = gamePhase === 'initial' ? 'flex' : 'none';
                document.getElementById('mulliganButtons').style.display = gamePhase === 'mulligan' ? 'flex' : 'none';
                document.getElementById('selectButtons').style.display = gamePhase === 'selecting' ? 'flex' : 'none';
                document.getElementById('playButtons').style.display = gamePhase === 'playing' ? 'flex' : 'none';

                if (gamePhase === 'mulligan') {
                    document.getElementById('xCount').textContent = mulliganCount;
                    document.getElementById('remulliganBtn').disabled = (mulliganCount >= 7);
                }
                if (gamePhase === 'selecting') {
                    document.getElementById('targetX').textContent = targetX;
                    document.getElementById('selectedCount').textContent = selectedIndices.length;
                    document.getElementById('confirmReturnBtn').disabled = (selectedIndices.length !== targetX);
                }
                if (gamePhase === 'playing') {
                    document.getElementById('drawBtn').disabled = (deck.length === 0);
                }

                renderZones();
                updateActionBar();
            }

            // æ¸²æŸ“ä¸»è¦åŒºåŸŸ
            function renderZones() {
                const renderZone = (zoneElement, cards, zoneName) => {
                    zoneElement.innerHTML = '';
                    if (cards.length === 0) {
                        zoneElement.innerHTML = '<div class="empty-message">ç©º</div>';
                        return;
                    }
                    cards.forEach((cardName, idx) => {
                        const cardDiv = document.createElement('div');
                        cardDiv.className = 'card';
                        cardDiv.dataset.cardname = cardName;
                        
                        if (zoneName === 'hand' && gamePhase === 'selecting') {
                            if (selectedIndices.includes(idx)) cardDiv.classList.add('selected');
                        } else {
                            if (selectedCard && selectedCard.zone === zoneName && selectedCard.index === idx) {
                                cardDiv.classList.add('selected');
                            }
                        }
                        cardDiv.textContent = cardName;

                        if (zoneName === 'hand' && gamePhase === 'selecting') {
                            cardDiv.addEventListener('click', (e) => { e.stopPropagation(); handleSelectingCardClick(idx); });
                        } else {
                            cardDiv.addEventListener('click', (e) => { e.stopPropagation(); selectCard(zoneName, idx); });
                        }
                        zoneElement.appendChild(cardDiv);
                    });
                };

                renderZone(document.getElementById('handZone'), hand, 'hand');
                renderZone(document.getElementById('battlefieldZone'), battlefield, 'battlefield');
                renderZone(document.getElementById('graveyardZone'), graveyard, 'graveyard');
                renderZone(document.getElementById('exileZone'), exile, 'exile');

                document.getElementById('handCount2').textContent = hand.length;
                document.getElementById('battlefieldCount').textContent = battlefield.length;
                document.getElementById('graveyardCount').textContent = graveyard.length;
                document.getElementById('exileCount').textContent = exile.length;
            }

            function updateActionBar() {
                const actionBar = document.getElementById('actionBar');
                if (gamePhase !== 'playing' || !selectedCard) {
                    actionBar.style.display = 'none';
                    return;
                }
                actionBar.style.display = 'flex';
                const zoneNames = { hand: 'æ‰‹ç‰Œ', battlefield: 'æˆ˜åœº', graveyard: 'å¢“åœ°', exile: 'æ”¾é€åŒº' };
                const currentZone = selectedCard.zone;
                const cardName = (currentZone === 'hand' ? hand : 
                                  currentZone === 'battlefield' ? battlefield :
                                  currentZone === 'graveyard' ? graveyard : exile)[selectedCard.index];
                document.getElementById('selectedInfo').textContent = `å½“å‰é€‰ä¸­ï¼š${zoneNames[currentZone]} - ${cardName}`;

                const targets = [];
                if (currentZone === 'hand') { targets.push('battlefield', 'graveyard', 'exile'); } 
                else { const allZones = ['hand', 'battlefield', 'graveyard', 'exile']; targets.push(...allZones.filter(z => z !== currentZone)); }

                const actionButtonsDiv = document.getElementById('actionButtons');
                actionButtonsDiv.innerHTML = '';
                targets.forEach(target => {
                    const btn = document.createElement('button');
                    btn.className = 'action-btn';
                    btn.textContent = `æ”¾å…¥${zoneNames[target]}`;
                    btn.addEventListener('click', () => moveCard(selectedCard.zone, selectedCard.index, target));
                    actionButtonsDiv.appendChild(btn);
                });
            }

            // ç§»åŠ¨å¡ç‰Œ
            function moveCard(fromZone, fromIndex, toZone) {
                if (fromZone === toZone) return;
                let card;
                switch (fromZone) {
                    case 'hand': card = hand.splice(fromIndex, 1)[0]; break;
                    case 'battlefield': card = battlefield.splice(fromIndex, 1)[0]; break;
                    case 'graveyard': card = graveyard.splice(fromIndex, 1)[0]; break;
                    case 'exile': card = exile.splice(fromIndex, 1)[0]; break;
                    default: return;
                }
                switch (toZone) {
                    case 'hand': hand.push(card); break;
                    case 'battlefield': battlefield.push(card); break;
                    case 'graveyard': graveyard.push(card); break;
                    case 'exile': exile.push(card); break;
                }
                selectedCard = null;
                updateUI(card);
            }

            function selectCard(zone, index) {
                if (gamePhase !== 'playing') return;
                if (selectedCard && selectedCard.zone === zone && selectedCard.index === index) selectedCard = null;
                else selectedCard = { zone, index };
                updateUI();
            }

            function handleSelectingCardClick(index) {
                if (gamePhase !== 'selecting') return;
                if (selectedIndices.includes(index)) {
                    selectedIndices = selectedIndices.filter(i => i !== index);
                } else {
                    if (selectedIndices.length < targetX) selectedIndices.push(index);
                    else alert(`æœ€å¤šåªèƒ½é€‰æ‹© ${targetX} å¼ ç‰Œæ”¾å›`);
                }
                document.getElementById('selectedCount').textContent = selectedIndices.length;
                document.getElementById('confirmReturnBtn').disabled = (selectedIndices.length !== targetX);
                renderZones();
            }

            // è°ƒåº¦ç›¸å…³
            function performMulligan() {
                if (mulliganCount >= 7) return;
                let combined = hand.concat(deck, battlefield, graveyard, exile);
                shuffleArray(combined);
                hand = combined.slice(0, 7);
                deck = combined.slice(7);
                battlefield = []; graveyard = []; exile = [];
                mulliganCount++;
                gamePhase = 'mulligan';
                selectedIndices = []; selectedCard = null;
                updateUI();
            }

            function acceptInitial() { gamePhase = 'playing'; selectedCard = null; updateUI(); }
            function startAcceptWithReturn() { targetX = mulliganCount; gamePhase = 'selecting'; selectedIndices = []; selectedCard = null; updateUI(); }
            function confirmReturn() {
                if (selectedIndices.length !== targetX) return;
                const selectedCards = selectedIndices.map(i => hand[i]);
                hand = hand.filter((_, i) => !selectedIndices.includes(i));
                deck.push(...selectedCards);
                mulliganCount = 0; gamePhase = 'playing'; selectedIndices = []; selectedCard = null; updateUI();
            }
            function cancelSelect() { gamePhase = 'mulligan'; selectedIndices = []; selectedCard = null; updateUI(); }
            function drawOneCard() {
                if (deck.length === 0) { alert('ç‰Œåº“å·²ç©ºï¼'); return; }
                const drawn = deck.shift();
                hand.push(drawn);
                updateUI(drawn);
            }

            // æœç´¢ç‰Œåº“
            function searchDeck() {
                const query = document.getElementById('searchInput').value.trim().toLowerCase();
                const resultsDiv = document.getElementById('searchResults');
                if (!query) { resultsDiv.innerHTML = '<div class="empty-message">è¾“å…¥å¡ååæœç´¢</div>'; return; }
                const matches = deck.filter(card => card.toLowerCase().includes(query));
                const uniqueMatches = [...new Set(matches)];
                if (uniqueMatches.length === 0) { resultsDiv.innerHTML = '<div class="empty-message">æœªæ‰¾åˆ°åŒ¹é…çš„ç‰Œ</div>'; return; }
                resultsDiv.innerHTML = '';
                uniqueMatches.forEach(cardName => {
                    const cardEl = document.createElement('div');
                    cardEl.className = 'search-card';
                    cardEl.textContent = cardName;
                    cardEl.addEventListener('click', () => {
                        selectedSearchCardName = cardName;
                        document.getElementById('selectedSearchCard').textContent = cardName;
                        document.getElementById('searchActions').style.display = 'flex';
                        document.querySelectorAll('.search-card').forEach(c => c.classList.remove('selected'));
                        cardEl.classList.add('selected');
                    });
                    resultsDiv.appendChild(cardEl);
                });
            }

            function handleSearchAction(targetZone) {
                if (!selectedSearchCardName) { alert('è¯·å…ˆç‚¹å‡»æœç´¢ç»“æœä¸­çš„ä¸€å¼ ç‰Œ'); return; }
                if (deck.length === 0) { alert('ç‰Œåº“ä¸ºç©ºï¼Œæ— æ³•æ“ä½œ'); return; }
                shuffleArray(deck);
                const index = deck.findIndex(card => card.toLowerCase() === selectedSearchCardName.toLowerCase());
                if (index === -1) { alert(`ç‰Œåº“ä¸­å·²æ²¡æœ‰ [${selectedSearchCardName}]`); return; }
                const card = deck.splice(index, 1)[0];
                switch (targetZone) {
                    case 'battlefield': battlefield.push(card); break;
                    case 'graveyard': graveyard.push(card); break;
                    case 'exile': exile.push(card); break;
                    case 'hand': hand.push(card); break;
                    case 'decktop': deck.unshift(card); break;
                }
                selectedSearchCardName = '';
                document.getElementById('searchActions').style.display = 'none';
                document.querySelectorAll('.search-card').forEach(c => c.classList.remove('selected'));
                updateUI(card);
            }

            // ========== æ¢å¤‡åŠŸèƒ½ ==========
            let tempMainboard = [], tempSideboard = [];  // ä¸´æ—¶ç¼–è¾‘

            function renderSideboardPanel() {
                const mainDiv = document.getElementById('panelMainCards');
                const sideDiv = document.getElementById('panelSideCards');
                mainDiv.innerHTML = ''; sideDiv.innerHTML = '';

                tempMainboard.forEach((card, idx) => {
                    const cardDiv = document.createElement('div');
                    cardDiv.className = 'card';
                    cardDiv.dataset.cardname = card;
                    cardDiv.textContent = card;
                    cardDiv.addEventListener('click', () => {
                        // ä»ä¸»ç‰Œç§»å‡ºä¸€å¼ åˆ°å¤‡ç‰Œ
                        tempMainboard.splice(idx, 1);
                        tempSideboard.push(card);
                        renderSideboardPanel();
                    });
                    mainDiv.appendChild(cardDiv);
                });
                tempSideboard.forEach((card, idx) => {
                    const cardDiv = document.createElement('div');
                    cardDiv.className = 'card';
                    cardDiv.dataset.cardname = card;
                    cardDiv.textContent = card;
                    cardDiv.addEventListener('click', () => {
                        // ä»å¤‡ç‰Œç§»å‡ºä¸€å¼ åˆ°ä¸»ç‰Œ
                        tempSideboard.splice(idx, 1);
                        tempMainboard.push(card);
                        renderSideboardPanel();
                    });
                    sideDiv.appendChild(cardDiv);
                });

                document.getElementById('panelMainCount').textContent = tempMainboard.length;
                document.getElementById('panelSideCount').textContent = tempSideboard.length;
            }

            // æ˜¾ç¤ºæ¢å¤‡é¢æ¿
            function showSideboard() {
                // åŸºäºå½“å‰å…¨å±€ä¸»ç‰Œå’Œå¤‡ç‰Œåˆå§‹åŒ–ä¸´æ—¶å‰¯æœ¬
                tempMainboard = [...mainboardList];
                tempSideboard = [...sideboardList];
                renderSideboardPanel();
                document.getElementById('sideboardPanel').style.display = 'block';
            }

            function hideSideboard() {
                document.getElementById('sideboardPanel').style.display = 'none';
            }

            // ç¡®è®¤æ¢å¤‡: æ›´æ–°å…¨å±€ä¸»/å¤‡ï¼Œé‡ç½®æ¸¸æˆ
            function confirmSideboard() {
                mainboardList = [...tempMainboard];
                sideboardList = [...tempSideboard];
                hideSideboard();
                resetGameWithDeck(mainboardList);  // ä½¿ç”¨æ–°ä¸»ç‰Œé‡ç½®æ¸¸æˆ
            }

            // ---------- äº‹ä»¶ç»‘å®š ----------
            document.getElementById('acceptInitialBtn').addEventListener('click', acceptInitial);
            document.getElementById('mulliganBtn').addEventListener('click', performMulligan);
            document.getElementById('acceptXBtn').addEventListener('click', startAcceptWithReturn);
            document.getElementById('remulliganBtn').addEventListener('click', performMulligan);
            document.getElementById('confirmReturnBtn').addEventListener('click', confirmReturn);
            document.getElementById('cancelSelectBtn').addEventListener('click', cancelSelect);
            document.getElementById('drawBtn').addEventListener('click', drawOneCard);
            document.getElementById('resetBtn').addEventListener('click', () => resetGameWithDeck(mainboardList));
            document.getElementById('searchBtn').addEventListener('click', searchDeck);
            document.getElementById('searchInput').addEventListener('keypress', (e) => { if (e.key === 'Enter') searchDeck(); });
            document.querySelectorAll('.search-actions .action-btn').forEach(btn => {
                btn.addEventListener('click', (e) => { const target = e.target.getAttribute('data-target'); handleSearchAction(target); });
            });
            document.getElementById('cancelSearchAction').addEventListener('click', () => {
                selectedSearchCardName = '';
                document.getElementById('searchActions').style.display = 'none';
                document.querySelectorAll('.search-card').forEach(c => c.classList.remove('selected'));
            });

            // åŠ è½½å¡ç»„ (ä½¿ç”¨æ–°è§£æ)
            document.getElementById('loadDeckBtn').addEventListener('click', () => {
                const deckText = document.getElementById('deckInput').value;
                const { mainboard, sideboard } = parseDeckFull(deckText);
                if (mainboard.length === 0) { alert('ä¸»ç‰Œæ ¼å¼é”™è¯¯ï¼Œè¯·æ£€æŸ¥è¾“å…¥'); return; }
                mainboardList = mainboard;
                sideboardList = sideboard;
                resetGameWithDeck(mainboardList);
            });

            // æ¢å¤é»˜è®¤å¡ç»„ (æ— å¤‡ç‰Œ)
            document.getElementById('defaultDeckBtn').addEventListener('click', () => {
                const defaultText = DEFAULT_CARD_COUNTS.map(([count, name]) => `${count} ${name}`).join('\n');
                document.getElementById('deckInput').value = defaultText;
                const { mainboard, sideboard } = parseDeckFull(defaultText);
                mainboardList = mainboard;
                sideboardList = sideboard;
                resetGameWithDeck(mainboardList);
            });

            // ä¿å­˜/åŠ è½½å·²ä¿å­˜ (ä¸å˜ï¼Œåªæ“ä½œæ–‡æœ¬)
            document.getElementById('saveDeckBtn').addEventListener('click', () => {
                const deckText = document.getElementById('deckInput').value;
                if (!deckText.trim()) { alert('å¡ç»„æ–‡æœ¬ä¸èƒ½ä¸ºç©º'); return; }
                const name = prompt('è¯·è¾“å…¥å¡ç»„åç§°ï¼š');
                if (name && name.trim()) { 
                    const decks = JSON.parse(localStorage.getItem('mtg_saved_decks') || '{}');
                    decks[name.trim()] = deckText;
                    localStorage.setItem('mtg_saved_decks', JSON.stringify(decks));
                    alert(`å¡ç»„â€œ${name}â€å·²ä¿å­˜`); 
                }
            });

            document.getElementById('loadSavedBtn').addEventListener('click', () => {
                const decks = JSON.parse(localStorage.getItem('mtg_saved_decks') || '{}');
                const names = Object.keys(decks);
                if (names.length === 0) { alert('æ²¡æœ‰å·²ä¿å­˜çš„å¡ç»„'); return; }
                const select = document.getElementById('savedDeckSelect');
                select.innerHTML = '';
                names.forEach(name => {
                    const option = document.createElement('option');
                    option.value = name; option.textContent = name;
                    select.appendChild(option);
                });
                document.getElementById('overlay').style.display = 'block';
                document.getElementById('deckDialog').style.display = 'block';
            });

            document.getElementById('loadSelectedDeck').addEventListener('click', () => {
                const selectedName = document.getElementById('savedDeckSelect').value;
                if (!selectedName) { alert('è¯·é€‰æ‹©ä¸€ä¸ªå¡ç»„'); return; }
                const decks = JSON.parse(localStorage.getItem('mtg_saved_decks') || '{}');
                const deckText = decks[selectedName];
                if (deckText) document.getElementById('deckInput').value = deckText;
                document.getElementById('overlay').style.display = 'none';
                document.getElementById('deckDialog').style.display = 'none';
            });

            document.getElementById('closeDeckDialog').addEventListener('click', () => {
                document.getElementById('overlay').style.display = 'none';
                document.getElementById('deckDialog').style.display = 'none';
            });
            document.getElementById('overlay').addEventListener('click', () => {
                document.getElementById('overlay').style.display = 'none';
                document.getElementById('deckDialog').style.display = 'none';
            });

            // æ¢å¤‡æŒ‰é’®äº‹ä»¶
            document.getElementById('sideboardBtn').addEventListener('click', showSideboard);
            document.getElementById('confirmSideboardBtn').addEventListener('click', confirmSideboard);
            document.getElementById('cancelSideboardBtn').addEventListener('click', hideSideboard);

            // åˆå§‹åŒ–ï¼šä»é»˜è®¤æ–‡æœ¬è§£æå¹¶å¯åŠ¨
            (function init() {
                const defaultText = DEFAULT_CARD_COUNTS.map(([count, name]) => `${count} ${name}`).join('\n');
                document.getElementById('deckInput').value = defaultText;
                const { mainboard, sideboard } = parseDeckFull(defaultText);
                mainboardList = mainboard;
                sideboardList = sideboard;
                resetGameWithDeck(mainboardList);
            })();

            // ---------- æ‚¬æµ®å¡å›¾ (ä¸å˜) ----------
            const tooltip = document.getElementById('card-tooltip');
            const tooltipImg = tooltip.querySelector('img');
            let currentTooltipCard = '';

            function updateTooltipPosition(e) {
                tooltip.style.left = (e.clientX + 20) + 'px';
                tooltip.style.top = (e.clientY + 20) + 'px';
            }

            function showTooltip(cardName, event) {
                currentTooltipCard = cardName;
                const cachedUrl = cardImageUrlMap.get(cardName);
                if (cachedUrl) tooltipImg.src = cachedUrl;
                else if (cachedUrl === null) tooltipImg.src = PLACEHOLDER_IMG;
                else {
                    tooltipImg.src = PLACEHOLDER_IMG;
                    fetchCardImageUrl(cardName).then(finalUrl => {
                        if (currentTooltipCard === cardName && tooltip.style.display === 'block') {
                            tooltipImg.src = finalUrl || PLACEHOLDER_IMG;
                        }
                    });
                }
                tooltip.style.display = 'block';
                updateTooltipPosition(event);
                document.addEventListener('mousemove', onTooltipMouseMove);
            }

            function hideTooltip() {
                tooltip.style.display = 'none';
                currentTooltipCard = '';
                document.removeEventListener('mousemove', onTooltipMouseMove);
            }

            function onTooltipMouseMove(e) {
                if (tooltip.style.display === 'block') updateTooltipPosition(e);
            }

            document.addEventListener('mouseover', (e) => {
                const trigger = e.target.closest('[data-cardname]');
                if (trigger) {
                    const cardName = trigger.dataset.cardname;
                    if (cardName && cardName !== 'â€”â€”') showTooltip(cardName, e);
                }
            });

            document.addEventListener('mouseout', (e) => {
                if (!e.target.closest('[data-cardname]')) hideTooltip();
            });
        })();
    </script>
</body>
</html>